import { IBaseQueries } from '@sqltools/types';
import { TREE_SEP } from '@sqltools/core/constants';

export default {
  describeTable: `
SELECT T.TABLE_NAME
  FROM "SYSIBM".Tables T
 WHERE T.TABLE_SCHEMA = ':schema'
   AND T.TABLE_NAME = ':table'
`,
  fetchColumns: `
SELECT T.TABLE_NAME AS TableName
  , C.COLUMN_NAME as ColumnName
  , C.DATA_TYPE as "Type"
  , CASE WHEN C.CHARACTER_MAXIMUM_LENGTH IS NOT NULL THEN C.CHARACTER_MAXIMUM_LENGTH
    WHEN C.NUMERIC_PRECISION IS NOT NULL THEN C.NUMERIC_PRECISION
    WHEN C.INTERVAL_PRECISION IS NOT NULL THEN C.INTERVAL_PRECISION
    WHEN C.DATETIME_PRECISION IS NOT NULL THEN C.DATETIME_PRECISION
    ELSE 0
    END as "Size"
  , T.TABLE_CATALOG AS TableCatalog
  , T.TABLE_SCHEMA as TableSchema
  , CURRENT_SERVER AS DbName
  , C.COLUMN_DEFAULT as DefaultValue
  , CASE WHEN C.IS_NULLABLE = 'YES' THEN 1
    Else 0
    END As IsNullable
  , CASE
    WHEN FP.COLUMN_NAME IS NOT NULL THEN 'P'
    WHEN FF.FKCOLUMN_NAME IS NOT NULL THEN 'R'
    ELSE NULL
    END AS KeyType
  , T.TABLE_CATALOG 
    || '${TREE_SEP}' || T.TABLE_SCHEMA
    || '${TREE_SEP}' || (
    CASE
    WHEN T.TABLE_TYPE = 'VIEW' THEN 'views'
    ELSE 'tables'
    END
    )
    || '${TREE_SEP}' || C.TABLE_NAME
    || '${TREE_SEP}' || C.COLUMN_NAME AS Tree
FROM "SYSIBM".Columns C
JOIN "SYSIBM".Tables T
 ON T.TABLE_SCHEMA = C.TABLE_SCHEMA
AND T.TABLE_NAME = C.TABLE_NAME
LEFT JOIN "SYSIBM".SQLPRIMARYKEYS FP
 ON FP.TABLE_SCHEM = T.TABLE_SCHEMA
AND FP.TABLE_NAME = T.TABLE_NAME
AND FP.COLUMN_NAME = C.COLUMN_NAME
LEFT JOIN "SYSIBM".SQLFOREIGNKEYS FF
 ON FF.FKTABLE_NAME = T.TABLE_SCHEMA
AND FF.FKTABLE_NAME = T.TABLE_NAME
AND FF.FKCOLUMN_NAME = C.COLUMN_NAME
WHERE T.TABLE_SCHEMA = Current_Schema
ORDER BY T.TABLE_CATALOG
  , T.TABLE_NAME
  , C.ORDINAL_POSITION
`,
  fetchRecords: 'SELECT * FROM :table FETCH FIRST :limit ROW ONLY',
  fetchTables: `
SELECT T.TABLE_NAME AS TableName
  , T.TABLE_SCHEMA as TableSchema
  , T.TABLE_CATALOG AS TableCatalog
  , CASE
    WHEN T.TABLE_TYPE = 'VIEW' THEN 1
    ELSE 0
    END AS IsView
  , T.TABLE_CATALOG AS DbName
  , C.CNT AS numberOfColumns
  , T.TABLE_CATALOG 
    || '${TREE_SEP}' || T.TABLE_SCHEMA
    || '${TREE_SEP}' || (
    CASE
    WHEN T.TABLE_TYPE = 'VIEW' THEN 'views'
    ELSE 'tables'
    END
    )
    || '${TREE_SEP}' || T.TABLE_NAME AS Tree
FROM "SYSIBM".TABLES T
JOIN (
    SELECT C.TABLE_SCHEMA AS TABLE_SCHEMA
         , C.TABLE_NAME AS TABLE_NAME
         , COUNT(*) AS CNT
      FROM "SYSIBM".COLUMNS C
     GROUP BY C.TABLE_SCHEMA, C.TABLE_NAME
    ) C
 ON C.TABLE_SCHEMA = T.TABLE_SCHEMA
AND C.TABLE_NAME = T.TABLE_NAME
WHERE T.TABLE_SCHEMA = Current_Schema
ORDER BY T.TABLE_NAME
`,
  fetchFunctions: `
  SELECT P.ROUTINE_NAME AS Name
  , P.ROUTINE_SCHEMA AS DbSchema
  , P.ROUTINE_CATALOG AS DbName
  , P.ROUTINE_SCHEMA || '.' || P.ROUTINE_NAME AS Signature
  , (
   SELECT LISTAGG(PM.PARAMETER_NAME || '=>' || PM.DATA_TYPE, ',') WITHIN GROUP (ORDER BY PM.ORDINAL_POSITION) AS Args
     FROM "SYSIBM".PARAMETERS PM
    WHERE PM.SPECIFIC_CATALOG = P.ROUTINE_CATALOG
      AND PM.SPECIFIC_SCHEMA = P.ROUTINE_SCHEMA
      AND PM.SPECIFIC_NAME = P.SPECIFIC_NAME
      AND PM.ORDINAL_POSITION <=32
   ) AS Args
  , P.DATA_TYPE AS ResultType
  , P.ROUTINE_CATALOG
    || '${TREE_SEP}' || P.ROUTINE_SCHEMA 
    || '${TREE_SEP}' || decode(P.ROUTINE_TYPE, 'PACKAGE', 'packages', 'FUNCTION', 'functions', 'PROCEDURE', 'procedures')
    || '${TREE_SEP}' || P.ROUTINE_NAME AS Tree
  , '' AS SOURCE
FROM "SYSIBM".ROUTINES P
WHERE LENGTH(P.ROUTINE_NAME) > 2
 AND P.ROUTINE_SCHEMA = Current_Schema
ORDER BY P.ROUTINE_CATALOG
     , P.ROUTINE_SCHEMA
     , P.ROUTINE_NAME
`
} as IBaseQueries;